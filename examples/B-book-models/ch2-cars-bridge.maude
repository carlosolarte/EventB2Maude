
--- Module generated by B2Maude (2023-07-12)
--- Context: 
--- Machine: 

--- MAX-STEPS for the simulation: 10000

load ../m-theory/ebmachine .

mod ctxCarBridge is
  inc EBMACHINE * (sort Configuration to Config) .

  --- Context: Sets and constants
  eq init-sets = 
  empty 
  .

  eq init-constants = 
   ('d |-> val(elt(10)))
  .

--- ===============================

--- VARIABLES 
 var $$a : EBType .
 var $$b : EBType .
 var $$c : EBType .

--- CONSTANTS 
 var $$d : EBType .

vars $$CNAME $$MNAME : Qid .
vars $$LEv $$LEv' : LEvent .
var  $$Sets : Map{Qid, EBSet} .
var  $$Cte  : Map{Qid, EBType} .
var  $$WEIGHT : Nat .
var  $$GUARD :  Bool . 

--- ===============================

  eq init-variables(  < $$CNAME : Context | sets: ($$Sets), constants: ('d |-> $$d) > )
   =
    ('a |-> val(elt(0))),
   ('b |-> val(elt(0))),
   ('c |-> val(elt(0))) .


----------------------------
--- Event MLIn
----------------------------

--- Activation of the Event MLIn
ceq [MLIn] :
    < $$CNAME : Context | sets: ($$Sets), constants: ('d |-> $$d) > 
  < $$MNAME : Machine | variables: ('a |-> $$a , 'b |-> $$b , 'c |-> $$c) > 
    < events  : Events  | state: ($$LEv ev('MLIn, unknown) $$LEv') >
    =
    < $$CNAME : Context | sets: ($$Sets), constants: ('d |-> $$d) > 
  < $$MNAME : Machine | variables: ('a |-> $$a , 'b |-> $$b , 'c |-> $$c) > 
    if $$WEIGHT > 0 and $$GUARD == true
    then 
    < events  : Events  | state: ($$LEv ev('MLIn, enable($$WEIGHT)) $$LEv') >
    else
    < events  : Events  | state: ($$LEv ev('MLIn, blocked) $$LEv') >
    fi
if      $$WEIGHT := ebset2nat(val(elt(1))) 
     /\ $$GUARD  := ebset2bool((val(elt(0))) < ($$c)) 
.

--- Change of state for event MLIn
rl [MLIn] : 
    < $$CNAME : Context | sets: ($$Sets), constants: ('d |-> $$d) > 
  < $$MNAME : Machine | variables: ('a |-> $$a , 'b |-> $$b , 'c |-> $$c) > 
    < events  : Events  | state: ( ev('MLIn, execute) ) >
    =>
      < $$CNAME : Context | sets: ($$Sets), constants: ('d |-> $$d) > 
    < $$MNAME : Machine | variables: ('a |-> $$a , 'b |-> $$b , 'c |-> ($$c) - (val(elt(1)))) > 
    < events : Events | state: init-events >
    .


----------------------------
--- Event MLOut
----------------------------

--- Activation of the Event MLOut
ceq [MLOut] :
    < $$CNAME : Context | sets: ($$Sets), constants: ('d |-> $$d) > 
  < $$MNAME : Machine | variables: ('a |-> $$a , 'b |-> $$b , 'c |-> $$c) > 
    < events  : Events  | state: ($$LEv ev('MLOut, unknown) $$LEv') >
    =
    < $$CNAME : Context | sets: ($$Sets), constants: ('d |-> $$d) > 
  < $$MNAME : Machine | variables: ('a |-> $$a , 'b |-> $$b , 'c |-> $$c) > 
    if $$WEIGHT > 0 and $$GUARD == true
    then 
    < events  : Events  | state: ($$LEv ev('MLOut, enable($$WEIGHT)) $$LEv') >
    else
    < events  : Events  | state: ($$LEv ev('MLOut, blocked) $$LEv') >
    fi
if      $$WEIGHT := ebset2nat(val(elt(1))) 
     /\ $$GUARD  := ebset2bool(((($$a) + ($$b)) < ($$d)) andb (($$c) =b (val(elt(0))))) 
.

--- Change of state for event MLOut
rl [MLOut] : 
    < $$CNAME : Context | sets: ($$Sets), constants: ('d |-> $$d) > 
  < $$MNAME : Machine | variables: ('a |-> $$a , 'b |-> $$b , 'c |-> $$c) > 
    < events  : Events  | state: ( ev('MLOut, execute) ) >
    =>
      < $$CNAME : Context | sets: ($$Sets), constants: ('d |-> $$d) > 
    < $$MNAME : Machine | variables: ('b |-> $$b , 'c |-> $$c , 'a |-> ($$a) + (val(elt(1)))) > 
    < events : Events | state: init-events >
    .


----------------------------
--- Event ILIn
----------------------------

--- Activation of the Event ILIn
ceq [ILIn] :
    < $$CNAME : Context | sets: ($$Sets), constants: ('d |-> $$d) > 
  < $$MNAME : Machine | variables: ('a |-> $$a , 'b |-> $$b , 'c |-> $$c) > 
    < events  : Events  | state: ($$LEv ev('ILIn, unknown) $$LEv') >
    =
    < $$CNAME : Context | sets: ($$Sets), constants: ('d |-> $$d) > 
  < $$MNAME : Machine | variables: ('a |-> $$a , 'b |-> $$b , 'c |-> $$c) > 
    if $$WEIGHT > 0 and $$GUARD == true
    then 
    < events  : Events  | state: ($$LEv ev('ILIn, enable($$WEIGHT)) $$LEv') >
    else
    < events  : Events  | state: ($$LEv ev('ILIn, blocked) $$LEv') >
    fi
if      $$WEIGHT := ebset2nat(val(elt(1))) 
     /\ $$GUARD  := ebset2bool((val(elt(0))) < ($$a)) 
.

--- Change of state for event ILIn
rl [ILIn] : 
    < $$CNAME : Context | sets: ($$Sets), constants: ('d |-> $$d) > 
  < $$MNAME : Machine | variables: ('a |-> $$a , 'b |-> $$b , 'c |-> $$c) > 
    < events  : Events  | state: ( ev('ILIn, execute) ) >
    =>
      < $$CNAME : Context | sets: ($$Sets), constants: ('d |-> $$d) > 
    < $$MNAME : Machine | variables: ('c |-> $$c , 'a |-> ($$a) - (val(elt(1))) , 'b |-> ($$b) + (val(elt(1)))) > 
    < events : Events | state: init-events >
    .


----------------------------
--- Event ILOut
----------------------------

--- Activation of the Event ILOut
ceq [ILOut] :
    < $$CNAME : Context | sets: ($$Sets), constants: ('d |-> $$d) > 
  < $$MNAME : Machine | variables: ('a |-> $$a , 'b |-> $$b , 'c |-> $$c) > 
    < events  : Events  | state: ($$LEv ev('ILOut, unknown) $$LEv') >
    =
    < $$CNAME : Context | sets: ($$Sets), constants: ('d |-> $$d) > 
  < $$MNAME : Machine | variables: ('a |-> $$a , 'b |-> $$b , 'c |-> $$c) > 
    if $$WEIGHT > 0 and $$GUARD == true
    then 
    < events  : Events  | state: ($$LEv ev('ILOut, enable($$WEIGHT)) $$LEv') >
    else
    < events  : Events  | state: ($$LEv ev('ILOut, blocked) $$LEv') >
    fi
if      $$WEIGHT := ebset2nat(val(elt(1))) 
     /\ $$GUARD  := ebset2bool(((val(elt(0))) < ($$b)) andb (($$a) =b (val(elt(0))))) 
.

--- Change of state for event ILOut
rl [ILOut] : 
    < $$CNAME : Context | sets: ($$Sets), constants: ('d |-> $$d) > 
  < $$MNAME : Machine | variables: ('a |-> $$a , 'b |-> $$b , 'c |-> $$c) > 
    < events  : Events  | state: ( ev('ILOut, execute) ) >
    =>
      < $$CNAME : Context | sets: ($$Sets), constants: ('d |-> $$d) > 
    < $$MNAME : Machine | variables: ('b |-> $$b , 'a |-> ($$b) - (val(elt(1))) , 'c |-> ($$c) + (val(elt(1)))) > 
    < events : Events | state: init-events >
    .


  --- Initialization of events
  eq init-events = ev('MLIn, unknown) ev('MLOut, unknown) ev('ILIn, unknown) ev('ILOut, unknown) .

  --- Rule for choosing the next event to be executed
  --- It stops when the system is in a deadlock or the limit 
  --- MAX-STEPS is reached. 
  var nsteps : Nat .
  crl [next-event] :
     < events : Events | state: ($$LEv) > 
     steps(nsteps)
     =>
     < events : Events | state: choose-event($$LEv') >
     steps(nsteps + 1)
  if
        nsteps <= MAX-STEPS
    /\  not-unknown($$LEv) --- all the guards have been checked
    /\  one-firable($$LEv) --- one of the events is firable
    /\  $$LEv' := accumulate(enabled-events($$LEv)) --- extract the enabled events and accumulate
  .

  --- --------------------------
  --- PVesTa -------------------
  --- --------------------------
  var Conf : Config .
  op tick : Config -> Config .
  eq tick( Conf )  = Conf .
  op MAX-STEPS : -> Nat .
  eq MAX-STEPS = 10000 .
  op steps : Nat -> Config .

  --- Observable properties
  op val : Nat Config -> Float .

  --- Simulation steps
  eq val(0, Conf steps(N:Nat) ) = float(N:Nat) .

  --- This definition depends on the system
  --- Change 1.0 with, for instance,   float(ebset2nat($$n)) 
  --- eq val(1, Conf < $$MNAME : Machine | variables: ('a |-> $$a , 'b |-> $$b , 'c |-> $$c) > ) = 1.0 . 
  --- Properties can be also defined in the .b file with a section PROPERTIES


eq val(1, Conf < $$MNAME : Machine | variables: ('a |-> $$a , 'b |-> $$b , 'c |-> $$c) > ) 
  = toFloat((($$a) >= (val(elt(0))))) .


  ---- Defining the initial state
  op initState : Nat -> Config .
  op initState : -> Config .
  rl initState => initState(counter) .

  eq initState(N:Nat) = init-machine('ctxCarBridge, 'CarBridgeSystem) steps(0)  .
endm

eof

--- example of use
rew [1] initState .

